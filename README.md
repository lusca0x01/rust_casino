# Rust Crash Game POC

A Rust Proof of Concept (POC) implementation of a Crash-style casino game server built with Rust and WebSockets.

## What are Crash Games?

Crash games are a category of online betting games characterized by real-time gameplay and a progressively increasing multiplier that eventually "crashes" (breaks or disappears).

Imagine an ascending graph, a rocket taking off, or a character flying higher and higher. This visual representation symbolizes your bet's multiplier, which grows every instant. The excitement of crash games lies in the unpredictability of when this multiplier will "crash" - that is, stop abruptly, zeroing the value for those who didn't cash out in time.

The core mechanic is simple yet thrilling:
- Players place their bets
- A multiplier starts at 1.00x and increases over time
- Players must cash out before the crash
- If you cash out in time, you win your bet multiplied by the current value
- If the game crashes before you cash out, you lose your bet

## How This POC Works

This implementation generates a provably fair game chain using:
- **Server Seed**: A random seed generated by the server
- **Client Seed**: A random seed that can be verified by clients
- **Hash Chain**: Uses HMAC-SHA256 to generate a deterministic chain of game outcomes
- **Point Calculation**: Each hash produces a crash point using cryptographic operations

The server broadcasts game results via WebSocket, sending the hash and crash point for each round every 2 seconds.

## Features

- WebSocket-based real-time communication using Axum
- Provably fair game generation
- HMAC-SHA256 hash chain for game integrity
- Configurable chain generation (10M outcomes by default)
- Automatic game regeneration when chain is exhausted
- JSON message format for easy client integration

## Tech Stack

- **Rust** - High-performance systems programming language
- **Axum** - Modern web framework with WebSocket support
- **Tokio** - Asynchronous runtime
- **SHA2/HMAC** - Cryptographic functions for provably fair games
- **Serde JSON** - Message serialization

## Prerequisites

- Rust 1.70+ (2021 edition)
- Cargo (comes with Rust)

## Installation & Compilation

1. **Clone the repository**
```bash
git clone <repository-url>
cd rust_cassino
```

2. **Build the project**
```bash
cargo build --release
```

3. **Run the server**
```bash
cargo run --release
```

The server will start on `http://127.0.0.1:3030` and display the generated seeds.

## Usage

### Server Endpoint

- **WebSocket Endpoint**: `ws://127.0.0.1:3030/crash`

### Message Format

The server sends JSON messages with the following structure:

```json
{
  "hash": "a1b2c3d4e5f6...",
  "point": 1.54
}
```

- `hash`: The cryptographic hash for this game round (for verification)
- `point`: The crash multiplier (0.0 means instant crash, >1.0 means crash at that multiplier)

### Connecting to the WebSocket

Example using JavaScript:

```javascript
const ws = new WebSocket('ws://127.0.0.1:3030/crash');

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log(`Hash: ${data.hash}, Crash Point: ${data.point}x`);
};

ws.onopen = () => {
  console.log('Connected to Crash Game');
};

ws.onerror = (error) => {
  console.error('WebSocket error:', error);
};
```

### Testing with CLI tools

Using `websocat`:
```bash
websocat ws://127.0.0.1:3030/crash
```

Using `wscat`:
```bash
wscat -c ws://127.0.0.1:3030/crash
```

## Project Structure

```
rust_cassino/
├── src/
│   ├── main.rs              # Server entry point and WebSocket handler
│   ├── game/
│   │   ├── mod.rs           # Game module exports
│   │   ├── chain_gen.rs     # Hash chain generation logic
│   │   └── game_logic.rs    # Crash point calculation
│   └── messages/
│       ├── mod.rs           # Message module exports
│       └── messages.rs      # JSON serialization/deserialization
├── Cargo.toml               # Project dependencies
└── README.md                # This file
```

## Configuration

You can modify the chain generation parameters in `main.rs`:

```rust
// Generate 10 million outcomes (adjust as needed)
let result = game::generate_chain(&server_seed, &client_seed, 10000000); // line 23
```

Adjust the broadcast interval (default is 2 seconds):

```rust
time::sleep(time::Duration::from_secs(2)).await; // line 70
```

## Demo

### Video Demonstration

_[Space reserved for video demonstration]_

## How to Verify Game Fairness

1. Record the server seed and client seed (displayed on server start)
2. Save the hash from each game result
3. Use the same seeds to regenerate the chain
4. Verify that the hashes match the ones received during gameplay

This proves that outcomes were predetermined and not manipulated in real-time.

## Performance

- Generates 10M outcomes in approximately 10-20 seconds (varies by hardware)
- Handles multiple concurrent WebSocket connections
- Low memory footprint with Rust's efficient memory management

## Limitations & Disclaimer

⚠️ **This is a POC (Proof of Concept) for educational purposes only.**

- No actual betting or money handling implemented
- No user authentication or session management
- No database persistence
- No frontend interface included
- Not intended for production use without significant enhancements

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

**Note**: This is an educational project demonstrating provably fair game mechanics. Please gamble responsibly and be aware of local gambling laws and regulations.
